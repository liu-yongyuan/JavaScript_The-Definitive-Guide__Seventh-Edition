// JavaScript 浮点数最大值
let o = 1.18_437_736_874_454_810_627;
console.log(o);

console.log("\n====== XXX ======\n");

let x = 0.3 - 0.2; // => 0.09999999999999998: 3角元减2角元
let y = 0.2 - 0.1; // => 0.1: 2角元-1角元
console.log(x === y); // => false: 这两个值不一样
console.log(x === 0.1); // => false: 0.3 - 0.2 不等于 0.1
console.log(y === 0.1); // => true: 0.2 - 0.1 等于 0.1
console.log(x, y); // => 0.09999999999999998 0.1

/**
 * 由于舍入错误, .3 和 .2 近似值的差与 .2 和 .1 近似值的差并不相等.
 * 这并不是 JavaScript 独有的问题, 而是所有使用二进制浮点数的编程语言共同的问题.
 * 同样, 也要注意代码中的 x 和 y 值极其接近, 它们也都及其接近正确的值. 这个计算得到的值完全能够满足任何需要, 切记不要比较它们的相等性.
 *
 * 如果浮点近似值对你的程序而言是个问题, 可以考虑使用等量整数. 例如, 计算与钱数有关的数值时可以使用整数形式的元, 而不是零点元
 */

console.log("\n====== XXX ======\n");

const hundred = 100;
let x1 = 0.3 * hundred - 0.2 * hundred;
let y1 = 0.2 * hundred - 0.1 * hundred;
console.log(x1, y1); // => 10, 10
console.log(0.3 * 100 - 0.2 * 100 - (0.2 * 100 - 0.1 * 100)); // => 0: 结果相等
console.log(x1 - y1); // => 0: 结果
console.log(x1 === y1); // =>true: 相等
console.log(x1 === 10); // =>true: 相等

/*  
  解决思路是乘以 10 的倍数再相减,除以 10 的的倍数得到小数部分
  乘 10 是将小数转成整数, 整数相减的差, 差除以 10 得到结果就是小数部分

  人类使用货币的策略,都是拿整数出去交易,注重数额与单位,应该是这个思路去处理钱相关的思路
  */
