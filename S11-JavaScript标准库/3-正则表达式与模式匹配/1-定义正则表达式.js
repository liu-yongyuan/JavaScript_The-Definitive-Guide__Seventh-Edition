const { next, log } = require("../../utils/log");

let pattern = /s$/;
log(pattern); // => /s$/
next();

pattern = new RegExp("s$");
log(pattern); // => /s$/
next();

/**
 * 正则表达式字面量字符
 * \0 NUL 字符(\u0000)
 * \t 制表符
 * \n 换行符
 * \v 垂直制表符
 * \f 进纸符
 * \r 回车符
 * \xnn 十六进制数值
 * \uxxxx
 * \u{n} 码点 n 指定的 Unicode 字符
 */

/* 
有一些英文标点符号再正则表达式中具有特殊含义
^ $ . * + ? = ! : | \ / ( ) [ ] { }
 */
next();

/**
 * 正则表达式字符类
 * [...] 方括号中的任意一个字符
 * [^...] 不在方括号中的任意一个字符
 * . 除换行符或其他 Unicode 行终止符之外的任意字符. 如果 RegExp 使用 s 标志,则句
 *    点匹配任意字符, 包括行终止符
 * \w 任意 ASCII 单词字符. 等价于 [a-zA-Z0-9_]
 * \W 任意非 ASCII 单词字符. 等价于 [^a-zA-Z0-9_]
 * \s 任意 Unicode 空白符
 * \S 任意非 Unicode 空白符
 * \d 任意 ASCII 数字字符. 等价于 [0-9]
 * \D 任意非 ASCII 数字字符. 等价于 [^0-9]
 * [\b] 退格字符字面值(特例)
 */

/**
 * 重复
 * {n,m} 匹配前项至少 n 次, 但不超过 m 次
 * {n,} 匹配前项 n 或更多次
 * {n} 匹配前项恰好 n 次
 * ? 匹配前项零或一次. 换句话说, 前项是可选的. 等价于{0,1}
 * + 匹配前项一或多次. 等价于{1,}
 * * 匹配前项零或多次. 等价于{0,}
 */


/**
 * 正则表达式任选, 分组和引用字符
 * \| 任选: 可以匹配左侧的子表达式, 也可以匹配右侧的子表达式
 * (...) 分组
 * (?:...) 仅分组
 */


/**
 * 正则表达式锚点字符
 * ^ 匹配字符串开头, 或者在使用 m 标志时, 匹配一行的开头
 * $ 匹配字符串末尾, 或者在使用 m 标志时, 匹配一行的末尾
 * \b 匹配单词的边界. 换句话说, 匹配 \w 字符和 \W 字符之间或 \w 与
 *    字符串开头或末尾之间的位置. 注意: [\b] 匹配退格字符
 * \B 匹配非单词边界的位置
 * (?=p) 肯定式向前查找断言. 要求后面的字符匹配模式 p, 但匹配结果
 *       不包含与之匹配的字符
 * (?!p) 否定式向前查找断言. 要求后面的字符不匹配模式 p
 */


/**
 * 标志
 * g
 * i 模式匹配应该不区分大小写
 * m
 * s
 * u
 * y
 */